Data Authorization and Verification
====================================

Decision Model
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. image:: ../images/data4.svg

How to implement reliable key management?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Pattern Features
------------------

In **Master & Sub Key Generation** pattern, each user can manage the subkeys used in different identities with a master-key. 
For example , a person can use different subkeys for the student identity or the citizenship identity to send transactions. 
It is difficult to track and associate these identities, and personal privacy can be protected. 
The subkey can be regenerated by the master key after it is lost, 
but if the master key is lost, it will lose control over the identity of all subkeys. 
Because of this weakness, reliability is reduced and the user needs to pay more attention to the master key.

In **Hot & Cold Wallet Storage** pattern, keys are stored in two types of wallets: hot and cold wallets. 
Users can operate on their accounts through hot wallets and save keys offline through cold wallets. 
Once the hot wallet is no longer secure by network attacks, 
the keys stored offline in the cold wallet can be used directly after networking, 
which has better reliability and security. But the use of the cold wallet is more complicated and increases the complexity of the system.

**Key Shards** splits the key into several different shards, and the key can be used only when the user gets adequate pieces of shards, 
which is similar to distributed private key control. 
The key is stored in pieces, thus the loss or damage of some pieces will not affect the storage of the key itself, 
which also reduces the risk of attack and is highly reliable. 
However, it requires additional resources to maintain the key shards. 
Moreover , the nodes storing key shards will still be the critical nodes to be attacked and the shards themselves cannot be recovered[14].

How to load status information?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Pattern Features
------------------

**Commit and Reveal** hides and commits a specific secret value without knowing to which values other entities are committed in the smart contract and is only revealed after the transaction is confirmed at a certain point in time. 
This pattern treats all of these committed values the same and the order of value is independent of transaction submitt order, 
and the intended execution of smart contracts can be realized, resulting in better flexibility [174]. 
Therefore, this pattern can be applied in many scenarios, such as voting schemes, lotteries, or when using zero-knowledge proofs. 
However, the on-chain execution is inefficient and complicated due to complicated implementation and massive overhead requirement in terms of privacy mechanism[11].

In **Encrypting On-chain Data**, one of the participants creates the key used to encrypt the data, then distributes it. 
The key is managed only through the off-chain method, 
and the relevant participants can decrypt the transactions using the secret key. 
Hence, the privacy mechanism in this pattern is more efficient and simple than the Commit and Reveal pattern. 
However, any participant needs to share the key first, leading to potential risk. 
Besides, it is not possible to revoke the participant's access to specific data. 
As long as the on-chain data is accessed once, it can be accessed all the time in the future, 
which is poorly flexible compared with traditional encryption mechanism. 
The dependency on off-chain key management method  also brings potential risks to transparency and security.

Communality
------------
- Both of them improve security and can effectively protect privacy:

  - Commit and Reveal hides part of the smart contract parameters to effectively protect private data and avoid attacks like the injection attack.

  - In Encrypting On-chain Data, data is protected by on-chain encryption, so that people without the key cannot know the data details. But the key is easily leaked by off-chain management and sharing, causing privacy risks.

- Both lead to increased overhead and cost:

  - Commit and Reveal needs a mechanism to hide contract variables, which will lead to increased complexity and more on-chain computation[11, 27].

  - In Encrypting On-chain Data, because of the implementation of on-chain encryption, additional components are required for off-chain shared keys, resulting in increased system overhead[13].

- Both lead to a decrease in credibility:

  - Both essentially add access control mechanisms to contract data using encryption, which can easily lead to centralization and reduced data transparency and credibility[11][13].